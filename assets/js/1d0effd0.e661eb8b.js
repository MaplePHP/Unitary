"use strict";(globalThis.webpackChunkunitary=globalThis.webpackChunkunitary||[]).push([[3609],{5717:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"type":"mdx","permalink":"/Unitary/why-unitary","source":"@site/src/pages/why-unitary.mdx","title":"Why Unitary","description":"Unitary exists to remove friction from testing. Most PHP testing tools are layered on top of legacy runners, assertion models, and plugin ecosystems. They are flexible, but slow, opaque, and difficult to reason about at scale. Configuration grows. Abstractions leak. Debugging becomes indirect.","frontMatter":{},"unlisted":false}');var t=i(4848),r=i(8453);const l={},a="Why Unitary",o={},c=[{value:"Unitary takes a different approach.",id:"unitary-takes-a-different-approach",level:4},{value:"What Problem Unitary Solves",id:"what-problem-unitary-solves",level:2},{value:"Evidence-Driven testing framework",id:"evidence-driven-testing-framework",level:2},{value:"Deterministic by Default",id:"deterministic-by-default",level:2},{value:"Hard Stops Where They Matter",id:"hard-stops-where-they-matter",level:2},{value:"Mocking Is a First-Class Feature",id:"mocking-is-a-first-class-feature",level:2},{value:"Zero Boilerplate Setup",id:"zero-boilerplate-setup",level:2},{value:"Built for Speed, Not Compatibility",id:"built-for-speed-not-compatibility",level:2},{value:"Security and Supply-Chain Awareness",id:"security-and-supply-chain-awareness",level:2},{value:"Feature Summary",id:"feature-summary",level:2},{value:"Philosophy",id:"philosophy",level:2}];function d(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"why-unitary",children:"Why Unitary"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Unitary exists to remove friction from testing."})," Most PHP testing tools are layered on top of legacy runners, assertion models, and plugin ecosystems. They are flexible, but slow, opaque, and difficult to reason about at scale. Configuration grows. Abstractions leak. Debugging becomes indirect."]}),"\n",(0,t.jsx)(n.h4,{id:"unitary-takes-a-different-approach",children:"Unitary takes a different approach."}),"\n",(0,t.jsxs)(n.p,{children:["It is a ",(0,t.jsx)(n.strong,{children:"Evidence-Driven testing framework"}),", built from scratch with ",(0,t.jsx)(n.strong,{children:"zero third-party runtime dependencies"}),", designed for ",(0,t.jsx)(n.strong,{children:"deterministic execution"}),", ",(0,t.jsx)(n.strong,{children:"full test isolation"}),", and ",(0,t.jsx)(n.strong,{children:"extreme performance"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"The result is a system where tests are fast enough to run constantly, precise enough to trust, and simple enough to stay out of your way."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"what-problem-unitary-solves",children:"What Problem Unitary Solves"}),"\n",(0,t.jsxs)(n.p,{children:["Traditional PHP testing frameworks optimize for compatibility and extensibility.\nUnitary optimizes for ",(0,t.jsx)(n.strong,{children:"clarity, control, and speed"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Common problems Unitary addresses:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Slow feedback loops that discourage full test runs"}),"\n",(0,t.jsx)(n.li,{children:"Assertion models that hide input and failure context"}),"\n",(0,t.jsx)(n.li,{children:"Mocking systems that fight the language"}),"\n",(0,t.jsx)(n.li,{children:"Complex configuration and bootstrapping"}),"\n",(0,t.jsx)(n.li,{children:"Non-deterministic execution order"}),"\n",(0,t.jsx)(n.li,{children:"Cascading failures that obscure the root cause"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Unitary removes these by design, not by convention."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"evidence-driven-testing-framework",children:"Evidence-Driven testing framework"}),"\n",(0,t.jsx)(n.p,{children:"Failures always show:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The validation that failed"}),"\n",(0,t.jsx)(n.li,{children:"The input value"}),"\n",(0,t.jsx)(n.li,{children:"The exact location"}),"\n",(0,t.jsx)(n.li,{children:"The line number"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"No guessing. No stepping through opaque assertion chains."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"deterministic-by-default",children:"Deterministic by Default"}),"\n",(0,t.jsxs)(n.p,{children:["Unitary executes tests ",(0,t.jsx)(n.strong,{children:"sequentially and deterministically"}),"."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"No hidden parallelism"}),"\n",(0,t.jsx)(n.li,{children:"No reordering"}),"\n",(0,t.jsx)(n.li,{children:"No shared state leakage"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This guarantees that:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A failing test always fails the same way"}),"\n",(0,t.jsx)(n.li,{children:"Debugging does not depend on execution timing"}),"\n",(0,t.jsx)(n.li,{children:"CI and local runs behave identically"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Performance comes from a fast core, not concurrency tricks."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"hard-stops-where-they-matter",children:"Hard Stops Where They Matter"}),"\n",(0,t.jsxs)(n.p,{children:["Unitary distinguishes between ",(0,t.jsx)(n.strong,{children:"validation failures"})," and ",(0,t.jsx)(n.strong,{children:"hard failures"}),"."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Validation failures are reported and execution continues"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"assert()"})," inside a group is a ",(0,t.jsx)(n.strong,{children:"strict halt"})]}),"\n",(0,t.jsx)(n.li,{children:"Fatal errors and unexpected exceptions stop the file immediately"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This gives you precise control over when execution should stop and when it should continue collecting failures."}),"\n",(0,t.jsx)(n.p,{children:"Per-group strict halts make it possible to protect critical invariants without sacrificing full reporting elsewhere."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"mocking-is-a-first-class-feature",children:"Mocking Is a First-Class Feature"}),"\n",(0,t.jsx)(n.p,{children:"Unitary includes a built-in mock engine. No adapters. No plugins."}),"\n",(0,t.jsx)("small",{children:(0,t.jsx)("strong",{children:"You can:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Mock classes or wrap real implementations"}),"\n",(0,t.jsx)(n.li,{children:"Override specific methods"}),"\n",(0,t.jsx)(n.li,{children:"Keep original behavior where needed"}),"\n",(0,t.jsx)(n.li,{children:"Define expectations, return values, and call counts"}),"\n",(0,t.jsx)(n.li,{children:"Mock final and private methods when required"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Mocking is explicit and local to the test group, ensuring ",(0,t.jsx)(n.strong,{children:"full isolation"}),"."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"zero-boilerplate-setup",children:"Zero Boilerplate Setup"}),"\n",(0,t.jsx)(n.p,{children:"There is nothing to configure to start testing."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"No bootstrap files"}),"\n",(0,t.jsx)(n.li,{children:"No XML or YAML"}),"\n",(0,t.jsx)(n.li,{children:"No annotations"}),"\n",(0,t.jsx)(n.li,{children:"No base classes"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Install the package, write a test file, run the CLI."}),"\n",(0,t.jsx)(n.p,{children:"Automatic discovery finds all test groups without scanning unrelated code paths."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"built-for-speed-not-compatibility",children:"Built for Speed, Not Compatibility"}),"\n",(0,t.jsx)(n.p,{children:"Unitary is not built on PHPUnit or any other legacy tool."}),"\n",(0,t.jsx)("small",{children:(0,t.jsx)("strong",{children:"The core is:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Purpose-built"}),"\n",(0,t.jsx)(n.li,{children:"Dependency-free"}),"\n",(0,t.jsx)(n.li,{children:"Optimized for low overhead"}),"\n"]}),"\n",(0,t.jsx)("small",{children:(0,t.jsx)("strong",{children:"This enables:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"100,000+ validations per second"}),"\n",(0,t.jsx)(n.li,{children:"Very low memory usage"}),"\n",(0,t.jsx)(n.li,{children:"Predictable CI runtimes"}),"\n",(0,t.jsx)(n.li,{children:"Fast local iteration"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Speed is not a benchmark feature. It is what makes disciplined testing practical."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"security-and-supply-chain-awareness",children:"Security and Supply-Chain Awareness"}),"\n",(0,t.jsx)(n.p,{children:"Unitary includes built-in inspection tools for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Dependency analysis"}),"\n",(0,t.jsx)(n.li,{children:"Supply-chain visibility"}),"\n",(0,t.jsx)(n.li,{children:"Vulnerability scanning"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"These run alongside tests, without additional tooling or CI glue."}),"\n",(0,t.jsx)(n.p,{children:"Testing correctness and dependency safety belong in the same workflow."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"feature-summary",children:"Feature Summary"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Validation-first engine"}),"\n",(0,t.jsx)(n.li,{children:"Deterministic sequential execution"}),"\n",(0,t.jsx)(n.li,{children:"Zero boilerplate setup"}),"\n",(0,t.jsx)(n.li,{children:"Extremely fast execution"}),"\n",(0,t.jsx)(n.li,{children:"Built-in mock engine"}),"\n",(0,t.jsx)(n.li,{children:"Per-group strict-halt assertions"}),"\n",(0,t.jsx)(n.li,{children:"Colorized, structured CLI output"}),"\n",(0,t.jsx)(n.li,{children:"Automatic test discovery"}),"\n",(0,t.jsx)(n.li,{children:"Configurable test paths"}),"\n",(0,t.jsx)(n.li,{children:"Run individual files or directories"}),"\n",(0,t.jsx)(n.li,{children:"Full test isolation"}),"\n",(0,t.jsx)(n.li,{children:"Input-bound validations"}),"\n",(0,t.jsx)(n.li,{children:"Optional descriptions"}),"\n",(0,t.jsx)(n.li,{children:"Detailed failure messages"}),"\n",(0,t.jsx)(n.li,{children:"Human-readable errors with input visibility"}),"\n",(0,t.jsx)(n.li,{children:"JUnit XML output"}),"\n",(0,t.jsx)(n.li,{children:"Debug mode"}),"\n",(0,t.jsx)(n.li,{children:"Built-in dependency and vulnerability inspection"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"philosophy",children:"Philosophy"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Test everything. All the time. Without friction."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"When tests are fast, clear, and predictable, they stop being a cost and start being a tool you rely on. That is the standard Unitary is built for."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>a});var s=i(6540);const t={},r=s.createContext(t);function l(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);